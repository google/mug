package com.google.mu.collect;

import static com.google.common.truth.Truth.assertThat;

import java.util.Arrays;

import org.junit.Test;
import org.junit.experimental.runners.Enclosed;
import org.junit.runner.RunWith;

import com.google.common.collect.Range;

/** Shows how some LeetCode binary search algorithms are solved with this library. */
@RunWith(Enclosed.class)
public class LeetCodeTest {

  static abstract class Koko {
    @Test public void verify() {
      assertThat(minEatingSpeed(new int[] {7}, 1)).isEqualTo(7);
      assertThat(minEatingSpeed(new int[] {3, 6, 7, 11}, 100)).isEqualTo(1);
      assertThat(minEatingSpeed(new int[] {30, 11, 23, 4, 20}, 5)).isEqualTo(30);
      assertThat(minEatingSpeed(new int[] {9}, 2)).isEqualTo(5);
      assertThat(minEatingSpeed(new int[] {1, 1, 1, 1}, 4)).isEqualTo(1);
      assertThat(minEatingSpeed(new int[] {1000000000}, 2)).isEqualTo(500000000);
    }

    abstract int minEatingSpeed(int[] piles, int h);

    static int eat(int[] piles, int speed) {
      int time = 0;
      for (int pile : piles) {
        time += (pile + speed - 1) / speed;
      }
      return time;
    }
  }

  public static class ManualKoKo extends Koko {
    // Generated by GPT
    @Override int minEatingSpeed(int[] piles, int h) {
      int low = 1, high = Arrays.stream(piles).max().getAsInt();
      while (low < high) {
        int mid = low + (high - low) / 2;
          if (eat(piles, mid) <= h) {
            high = mid;
          } else {
            low = mid + 1;
          }
      }
      return low;
    }
  }

  public static class MugKoko extends Koko {
    @Override int minEatingSpeed(int[] piles, final int h) {
      return BinarySearch.forInts(Range.closed(1, Arrays.stream(piles).max().getAsInt()))
          .insertionPointFor((lo, speed, hi) -> eat(piles, speed) <= h ? -1 : 1)
          .ceiling();
    }
  }

  static abstract class Sqrt {
    @Test public void verify() {
      assertThat(mySqrt(0)).isEqualTo(0);
      assertThat(mySqrt(1)).isEqualTo(1);
      assertThat(mySqrt(2)).isEqualTo(1);
      assertThat(mySqrt(3)).isEqualTo(1);
      assertThat(mySqrt(4)).isEqualTo(2);
      assertThat(mySqrt(10)).isEqualTo(3);
      assertThat(mySqrt(2147395599)).isEqualTo(46339);
    }

    abstract int mySqrt(int x);
  }

  public static class ManualSqrt extends Sqrt {
    @Override int mySqrt(int x) {
      int low = 0, high = x;
      while (low <= high) {
          int mid = low + (high - low) / 2;
          if ((long) mid * mid <= x) {
              low = mid + 1;
          } else {
              high = mid - 1;
          }
      }
      return high;
    }
  }

  public static class MugSqrt extends Sqrt {
    @Override int mySqrt(int x) {
      return BinarySearch.forInts(Range.closed(0, x))
          .insertionPointFor((lo, mid, hi) -> Long.compare(x, (long) mid * mid))
          .floor();
    }
  }

  static abstract class FindDuplicate {
    @Test public void verifyCorrectness() {
      assertThat(findDuplicate(new int[]{1,1})).isEqualTo(1);
      assertThat(findDuplicate(new int[]{1,1,2})).isEqualTo(1);
      assertThat(findDuplicate(new int[]{2,2,2,2,2})).isEqualTo(2);
      assertThat(findDuplicate(new int[]{1,3,4,2,2})).isEqualTo(2);
      assertThat(findDuplicate(new int[]{3,1,3,4,2})).isEqualTo(3);
    }

    abstract int findDuplicate(int[] nums);
  }

  public static class ManualFindDuplicate extends FindDuplicate {
    @Override int findDuplicate(int[] nums) {
      int low = 1, high = nums.length - 1;
      while (low < high) {
          int mid = (low + high) / 2;
          int count = 0;
          for (int num : nums) {
              if (num <= mid) count++;
          }
          if (count > mid) {
              high = mid;
          } else {
              low = mid + 1;
          }
      }
      return low;
    }
  }

  public static class MugFindDuplicate extends FindDuplicate {
    @Override int findDuplicate(int[] nums) {
      return BinarySearch.forInts(Range.closed(1, nums.length - 1))
          .insertionPointFor(
              (lo, mid, hi) ->
                  Arrays.stream(nums).filter(n -> n <= mid).count() > mid ? -1 : 1)
          .ceiling();
    }
  }

  static abstract class WoodCutting {
    @Test public void verifyCorrectness() {
      assertThat(woodCut(new int[]{232, 124, 456}, 7)).isEqualTo(114);
    }

    abstract int woodCut(int[] lengths, int k);
  }

  public static class ManualWoodCutting extends WoodCutting {
    @Override int woodCut(int[] lengths, int k) {
      int low = 1, high = Arrays.stream(lengths).max().getAsInt();
      while (low <= high) {
          int mid = low + (high - low) / 2;
          int count = 0;
          for (int len : lengths) {
              count += len / mid;
          }
          if (count >= k) {
              low = mid + 1;
          } else {
              high = mid - 1;
          }
      }
      return high;
    }
  }

  public static class MugWoodCutting extends WoodCutting {
    @Override int woodCut(int[] lengths, int k) {
        return BinarySearch.forInts(Range.closed(1, Arrays.stream(lengths).max().getAsInt()))
            .insertionPointFor(
                (lo, mid, hi) ->
                    Integer.compare(Arrays.stream(lengths).map(len -> len / mid).sum(), k))
            .floor();
    }
  }

  static abstract class SplitArray {
    @Test public void verifyCorrectness() {
      assertThat(splitArray(new int[]{1}, 1)).isEqualTo(1);
      assertThat(splitArray(new int[]{1, 2, 3, 4, 5}, 5)).isEqualTo(5);
      assertThat(splitArray(new int[]{7,2,5,10,8}, 2)).isEqualTo(18);
    }

    abstract int splitArray(int[] nums, int k);

    static boolean canSplit(int[] nums, int k, int maxSum) {
        int count = 1, sum = 0;
        for (int num : nums) {
            if (sum + num > maxSum) {
                count++;
                sum = 0;
            }
            sum += num;
        }
        return count <= k;
    }
  }

  public static class ManualSplitArray extends SplitArray {
    @Override int splitArray(int[] nums, int k) {
      int low = Arrays.stream(nums).max().getAsInt();
      int high = Arrays.stream(nums).sum();
      while (low < high) {
          int mid = (low + high) / 2;
          if (canSplit(nums, k, mid)) {
              high = mid;
          } else {
              low = mid + 1;
          }
      }
      return low;
    }
  }

  public static class MugSplitArray extends SplitArray {
    @Override int splitArray(int[] nums, int k) {
      int low = Arrays.stream(nums).max().getAsInt();
      int high = Arrays.stream(nums).sum();
      return BinarySearch.forInts(Range.closed(low, high))
          .insertionPointFor((lo, mid, hi) -> canSplit(nums, k, mid) ? -1 : 1)
          .ceiling();
    }
  }

  static abstract class ShipWithinNDays {
    @Test public void verifyCorrectness() {
      assertThat(shipWithinDays(new int[]{1}, 1)).isEqualTo(1);
      assertThat(shipWithinDays(new int[]{1,2,3,1,1}, 4)).isEqualTo(3);
      assertThat(shipWithinDays(new int[]{10,50,50,10}, 2)).isEqualTo(60);
      assertThat(shipWithinDays(new int[]{3,2,2,4,1,4}, 3)).isEqualTo(6);
    }

    abstract int shipWithinDays(int[] weights, int D);

    static boolean canShip(int[] weights, int D, int capacity) {
      int days = 1, sum = 0;
      for (int w : weights) {
          if (sum + w > capacity) {
              days++;
              sum = 0;
          }
          sum += w;
      }
      return days <= D;
    }
  }

  public static class ManualShipWithinNDays extends ShipWithinNDays {
    @Override int shipWithinDays(int[] weights, int D) {
      int low = Arrays.stream(weights).max().getAsInt();
      int high = Arrays.stream(weights).sum();
      while (low < high) {
          int mid = (low + high) / 2;
          if (canShip(weights, D, mid)) {
              high = mid;
          } else {
              low = mid + 1;
          }
      }
      return low;
    }
  }

  public static class MugShipWithinNDays extends ShipWithinNDays {
    @Override int shipWithinDays(int[] weights, int D) {
      int low = Arrays.stream(weights).max().getAsInt();
      int high = Arrays.stream(weights).sum();
      return BinarySearch.forInts(Range.closed(low, high))
          .insertionPointFor((lo, mid, hi) -> canShip(weights, D, mid) ? -1 : 1)
          .ceiling();
    }
  }

  static abstract class KthSmallest {
    @Test public void verifyCorrectness() {
      assertThat(kthSmallest(new int[][]{{1}}, 1)).isEqualTo(1);
      assertThat(kthSmallest(new int[][]{{1,2},{1,3}}, 2)).isEqualTo(1);
      assertThat(kthSmallest(new int[][]{{1,5,9},{10,11,13},{12,13,15}}, 8)).isEqualTo(13);
    }

    abstract int kthSmallest(int[][] matrix, int k);

    static int countLessEqual(int[][] matrix, int target) {
      int count = 0, n = matrix.length, j = n - 1;
      for (int i = 0; i < n; i++) {
          while (j >= 0 && matrix[i][j] > target) j--;
          count += (j + 1);
      }
      return count;
    }
  }

  public static class ManualKthSmallest extends KthSmallest {
    @Override int kthSmallest(int[][] matrix, int k) {
      int n = matrix.length;
      int low = matrix[0][0], high = matrix[n-1][n-1];
      while (low < high) {
          int mid = low + (high - low) / 2;
          int count = countLessEqual(matrix, mid);
          if (count < k) {
              low = mid + 1;
          } else {
              high = mid;
          }
      }
      return low;
    }
  }

  public static class MugKthSmallest extends KthSmallest {
    @Override int kthSmallest(int[][] matrix, int k) {
      int n = matrix.length;
      return BinarySearch.forInts(Range.closed(matrix[0][0], matrix[n-1][n-1]))
          .insertionPointFor((lo, mid, hi) -> countLessEqual(matrix, mid) < k ? 1 : -1)
          .ceiling();
    }
  }

  static abstract class FindMaxAverage {
    @Test public void verifyCorrectness() {
      assertThat(findMaxAverage(new int[]{1,12,-5,-6,50,3}, 4))
          .isWithin(0.01)
          .of(12.75);;
    }

    abstract double findMaxAverage(int[] nums, int k);

    static boolean check(int[] nums, int k, double avg) {
      double sum = 0, prev = 0, minPrev = 0;
      for (int i = 0; i < k; ++i) {
          sum += nums[i] - avg;
      }
      if (sum >= 0) return true;
      for (int i = k; i < nums.length; ++i) {
          sum += nums[i] - avg;
          prev += nums[i - k] - avg;
          minPrev = Math.min(minPrev, prev);
          if (sum >= minPrev) return true;
      }
      return false;
    }
  }

  public static class ManualFindMaxAverage extends FindMaxAverage {
    @Override double findMaxAverage(int[] nums, int k) {
      double low = -10000, high = 10000;
      while (high - low > 1e-5) {
          double mid = (low + high) / 2;
          if (check(nums, k, mid)) {
              low = mid;
          } else {
              high = mid;
          }
      }
      return low;
    }
  }

  public static class MugFindMaxAverage extends FindMaxAverage {
    @Override double findMaxAverage(int[] nums, int k) {
      return BinarySearch.forDoubles(Range.closed(-10000.0, 10000.0))
          .insertionPointFor((lo, mid, hi) -> check(nums, k, mid) ? 1 : -1)
          .floor();
    }
  }

  static abstract class FindSmallestLetterGreaterThanTarget {
    abstract char find(char[] letters, char target);

    @Test public void verify() {
      assertThat(find(new char[]{'c','f','j'}, 'a')).isEqualTo('c');
      assertThat(find(new char[]{'c','f','j'}, 'c')).isEqualTo('f');
      assertThat(find(new char[]{'c','f','j'}, 'd')).isEqualTo('f');
      assertThat(find(new char[]{'c','f','j'}, 'g')).isEqualTo('j');
      assertThat(find(new char[]{'c','f','j'}, 'j')).isEqualTo('c'); // wrap
      assertThat(find(new char[]{'c','f','j'}, 'k')).isEqualTo('c'); // wrap
    }
  }

  public static class MugFindSmallestLetterGreaterThanTarget extends FindSmallestLetterGreaterThanTarget {
    @Override char find(char[] letters, char target) {
      int index = BinarySearch.forInts(Range.closed(0, letters.length - 1))
          // greater? move left; else move right
          .insertionPointFor((lo, mid, hi) -> letters[mid] > target ? -1 : 1)
          .ceiling();

      return index == letters.length ? letters[0] : letters[index];
    }
  }
}
