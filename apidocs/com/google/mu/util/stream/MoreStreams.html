<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (12.0.1) on Sat Mar 09 13:57:07 PST 2024 -->
<title>MoreStreams (core 7.2-SNAPSHOT API)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="dc.created" content="2024-03-09">
<link rel="stylesheet" type="text/css" href="../../../../../javadoc-stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../../../../../script.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../../../../../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../../../../../jquery/jquery-3.3.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-migrate-3.0.1.js"></script>
<script type="text/javascript" src="../../../../../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="MoreStreams (core 7.2-SNAPSHOT API)";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":9,"i1":9,"i2":9,"i3":9,"i4":9,"i5":9,"i6":9,"i7":9,"i8":9,"i9":9,"i10":9,"i11":9,"i12":9,"i13":9,"i14":9};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../../../../../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/MoreStreams.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">com.google.mu.util.stream</a></div>
<h2 title="Class MoreStreams" class="title">Class MoreStreams</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>com.google.mu.util.stream.MoreStreams</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<pre>public final class <span class="typeNameLabel">MoreStreams</span>
extends java.lang.Object</pre>
<div class="block">Static utilities pertaining to <code>Stream</code> in addition to relevant utilities in JDK and Guava.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.1</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<div class="memberSummary">
<div role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="memberSummary_tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="activeTableTab">All Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="tableTab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="memberSummary_tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t4" class="tableTab" onclick="show(8);">Concrete Methods</button></div>
<div id="memberSummary_tabpanel" role="tabpanel">
<table aria-labelledby="t0">
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tbody>
<tr class="altColor" id="i0">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.Spliterator&lt;java.util.List&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dice(java.util.Spliterator,int)">dice</a></span>&#8203;(java.util.Spliterator&lt;? extends T&gt;&nbsp;spliterator,
    int&nbsp;maxSize)</code></th>
<td class="colLast">
<div class="block">Dices <code>spliterator</code> into smaller chunks each with up to <code>maxSize</code> elements.</div>
</td>
</tr>
<tr class="rowColor" id="i1">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Stream&lt;java.util.List&lt;T&gt;&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dice(java.util.stream.Stream,int)">dice</a></span>&#8203;(java.util.stream.Stream&lt;? extends T&gt;&nbsp;stream,
    int&nbsp;maxSize)</code></th>
<td class="colLast">
<div class="block">Dices <code>stream</code> into smaller chunks each with up to <code>maxSize</code> elements.</div>
</td>
</tr>
<tr class="altColor" id="i2">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#flatten(java.util.stream.Stream)">flatten</a></span>&#8203;(java.util.stream.Stream&lt;? extends java.util.stream.Stream&lt;? extends T&gt;&gt;&nbsp;streamOfStream)</code></th>
<td class="colLast">
<div class="block">Flattens <code>streamOfStream</code> and returns an unordered sequential stream of the nested
 elements.</div>
</td>
</tr>
<tr class="rowColor" id="i3">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#generate(T,java.util.function.Function)">generate</a></span>&#8203;(T&nbsp;seed,
        java.util.function.Function&lt;? super T,&#8203;? extends java.util.stream.Stream&lt;? extends T&gt;&gt;&nbsp;step)</code></th>
<td class="colLast">
<div class="block">Returns a Stream produced by iterative application of <code>step</code> to the initial
 <code>seed</code>, producing a Stream consisting of seed, elements of step(seed),
 elements of step(x) for each x in step(seed), etc.</div>
</td>
</tr>
<tr class="altColor" id="i4">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupConsecutive(java.util.stream.Stream,java.util.function.BiPredicate,java.util.function.BinaryOperator)">groupConsecutive</a></span>&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream,
                java.util.function.BiPredicate&lt;? super T,&#8203;? super T&gt;&nbsp;sameGroup,
                java.util.function.BinaryOperator&lt;T&gt;&nbsp;groupReducer)</code></th>
<td class="colLast">
<div class="block">Groups consecutive elements from <code>stream</code> lazily.</div>
</td>
</tr>
<tr class="rowColor" id="i5">
<td class="colFirst"><code>static &lt;T,&#8203;R&gt;<br>java.util.stream.Stream&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupConsecutive(java.util.stream.Stream,java.util.function.BiPredicate,java.util.stream.Collector)">groupConsecutive</a></span>&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream,
                java.util.function.BiPredicate&lt;? super T,&#8203;? super T&gt;&nbsp;sameGroup,
                java.util.stream.Collector&lt;? super T,&#8203;?,&#8203;R&gt;&nbsp;groupCollector)</code></th>
<td class="colLast">
<div class="block">Groups consecutive elements from <code>stream</code> lazily.</div>
</td>
</tr>
<tr class="altColor" id="i6">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupConsecutive(java.util.stream.Stream,java.util.function.Function,java.util.function.BinaryOperator)">groupConsecutive</a></span>&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream,
                java.util.function.Function&lt;? super T,&#8203;?&gt;&nbsp;groupKeyFunction,
                java.util.function.BinaryOperator&lt;T&gt;&nbsp;groupReducer)</code></th>
<td class="colLast">
<div class="block">Groups consecutive elements from <code>stream</code> lazily.</div>
</td>
</tr>
<tr class="rowColor" id="i7">
<td class="colFirst"><code>static &lt;T,&#8203;R&gt;<br>java.util.stream.Stream&lt;R&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#groupConsecutive(java.util.stream.Stream,java.util.function.Function,java.util.stream.Collector)">groupConsecutive</a></span>&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream,
                java.util.function.Function&lt;? super T,&#8203;?&gt;&nbsp;groupKeyFunction,
                java.util.stream.Collector&lt;? super T,&#8203;?,&#8203;R&gt;&nbsp;groupCollector)</code></th>
<td class="colLast">
<div class="block">Groups consecutive elements from <code>stream</code> lazily.</div>
</td>
</tr>
<tr class="altColor" id="i8">
<td class="colFirst"><code>static java.util.stream.Stream&lt;java.lang.Integer&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#indexesFrom(int)">indexesFrom</a></span>&#8203;(int&nbsp;firstIndex)</code></th>
<td class="colLast">
<div class="block">Returns an infinite <code>Stream</code> starting from <code>firstIndex</code>.</div>
</td>
</tr>
<tr class="rowColor" id="i9">
<td class="colFirst"><code>static java.util.stream.Stream&lt;java.lang.Long&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#indexesFrom(long)">indexesFrom</a></span>&#8203;(long&nbsp;firstIndex)</code></th>
<td class="colLast">
<div class="block">Returns an infinite index stream starting from <code>firstIndex</code>.</div>
</td>
</tr>
<tr class="altColor" id="i10">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.lang.Iterable&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#iterateOnce(java.util.stream.Stream)">iterateOnce</a></span>&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream)</code></th>
<td class="colLast">
<div class="block">Iterates through <code>stream</code> <em>only once</em>.</div>
</td>
</tr>
<tr class="rowColor" id="i11">
<td class="colFirst"><code>static &lt;T,&#8203;E extends java.lang.Throwable&gt;<br>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#iterateThrough(java.util.stream.Stream,com.google.mu.function.CheckedConsumer)">iterateThrough</a></span>&#8203;(java.util.stream.Stream&lt;? extends T&gt;&nbsp;stream,
              <a href="../../function/CheckedConsumer.html" title="interface in com.google.mu.function">CheckedConsumer</a>&lt;? super T,&#8203;E&gt;&nbsp;consumer)</code></th>
<td class="colLast">
<div class="block">Iterates through <code>stream</code> sequentially and passes each element to <code>consumer</code>
 with exceptions propagated.</div>
</td>
</tr>
<tr class="altColor" id="i12">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;<a href="BiStream.html" title="class in com.google.mu.util.stream">BiStream</a>&lt;T,&#8203;java.lang.Long&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#runLengthEncode(java.util.stream.Stream,java.util.function.BiPredicate)">runLengthEncode</a></span>&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream,
               java.util.function.BiPredicate&lt;? super T,&#8203;? super T&gt;&nbsp;sameGroup)</code></th>
<td class="colLast">
<div class="block">Groups consecutive items in <code>stream</code> using the <code>sameGroup</code> predicate, along with
 the group's run length (number of items).</div>
</td>
</tr>
<tr class="rowColor" id="i13">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#whileNotNull(java.util.function.Supplier)">whileNotNull</a></span>&#8203;(java.util.function.Supplier&lt;? extends T&gt;&nbsp;supplier)</code></th>
<td class="colLast">
<div class="block">Similar to <code>Stream.generate(java.util.function.Supplier&lt;? extends T&gt;)</code>, returns an infinite, sequential, ordered, and non-null
 stream where each element is generated by the provided Supplier.</div>
</td>
</tr>
<tr class="altColor" id="i14">
<td class="colFirst"><code>static &lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#withSideEffect(java.util.stream.Stream,java.util.function.Consumer)">withSideEffect</a></span>&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream,
              java.util.function.Consumer&lt;? super T&gt;&nbsp;sideEffect)</code></th>
<td class="colLast">
<div class="block">Returns a sequential stream with <code>sideEfect</code> attached on every element.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="generate(java.lang.Object,java.util.function.Function)">
<!--   -->
</a><a id="generate(T,java.util.function.Function)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>generate</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;&nbsp;generate&#8203;(T&nbsp;seed,
                                                      java.util.function.Function&lt;? super T,&#8203;? extends java.util.stream.Stream&lt;? extends T&gt;&gt;&nbsp;step)</pre>
<div class="block">Returns a Stream produced by iterative application of <code>step</code> to the initial
 <code>seed</code>, producing a Stream consisting of seed, elements of step(seed),
 elements of step(x) for each x in step(seed), etc.
 (If the result stream returned by the <code>step</code> function is null an empty stream is used,
 instead.)

 <p>While <code>Stream.generate(supplier)</code> can be used to generate infinite streams,
 it's not as easy to generate a <em>finite</em> stream unless the size can be pre-determined.
 This method can be used to generate finite streams: just return an empty stream when the
 <code>step</code> determines that there's no more elements to be generated.

 <p>A typical group of use cases are BFS traversal algorithms.
 For example, to stream the tree nodes in BFS order: <pre><code>
   Stream&lt;Node&gt; bfs(Node root) {
     return generate(root, node -&gt; node.children().stream());
   }
 </code></pre>

 It's functionally equivalent to the following common imperative code: <pre><code>
   List&lt;Node&gt; bfs(Node root) {
     List&lt;Node&gt; result = new ArrayList&lt;&gt;();
     Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();
     queue.add(root);
     while (!queue.isEmpty()) {
       Node node = queue.remove();
       result.add(node);
       queue.addAll(node.children());
     }
     return result;
   }
 </code></pre>

 A BFS 2-D grid traversal algorithm: <pre><code>
   Stream&lt;Cell&gt; bfs(Cell startingCell) {
     Set&lt;Cell&gt; visited = new HashSet&lt;&gt;();
     visited.add(startingCell);
     return generate(startingCell, c -&gt; c.neighbors().filter(visited::add));
   }
 </code></pre>

 <p>At every step, 0, 1 or more elements can be generated into the resulting stream.
 As discussed above, returning an empty stream leads to eventual termination of the stream;
 returning 1-element stream is equivalent to <code>Stream.generate(supplier)</code>;
 while returning more than one elements allows a single element to fan out to multiple
 elements.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.9</dd>
</dl>
</li>
</ul>
<a id="flatten(java.util.stream.Stream)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flatten</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;&nbsp;flatten&#8203;(java.util.stream.Stream&lt;? extends java.util.stream.Stream&lt;? extends T&gt;&gt;&nbsp;streamOfStream)</pre>
<div class="block">Flattens <code>streamOfStream</code> and returns an unordered sequential stream of the nested
 elements.

 <p>Logically, <code>stream.flatMap(fanOut)</code> is equivalent to
 <code>MoreStreams.flatten(stream.map(fanOut))</code>.
 Due to this <a href="https://bugs.openjdk.java.net/browse/JDK-8075939">JDK bug</a>,
 <code>flatMap()</code> uses <code>forEach()</code> internally and doesn't support short-circuiting for
 the passed-in stream. <code>flatten()</code> supports short-circuiting and can be used to
 flatten infinite streams.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>1.9</dd>
</dl>
</li>
</ul>
<a id="groupConsecutive(java.util.stream.Stream,java.util.function.BiPredicate,java.util.stream.Collector)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupConsecutive</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;R&gt;&nbsp;java.util.stream.Stream&lt;R&gt;&nbsp;groupConsecutive&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream,
                                                                      java.util.function.BiPredicate&lt;? super T,&#8203;? super T&gt;&nbsp;sameGroup,
                                                                      java.util.stream.Collector&lt;? super T,&#8203;?,&#8203;R&gt;&nbsp;groupCollector)</pre>
<div class="block">Groups consecutive elements from <code>stream</code> lazily. Two consecutive elements belong to the
 same group if <code>sameGroup</code> evaluates to true. Consecutive elements belonging to the same
 group will be collected together using <code>groupCollector</code>.

 <p>For example, you can find every list of increasing stock prices, given daily stock prices:

 <pre><code>
 ImmutableList&lt;ImmutableList&lt;Double&gt;&gt; increasingStockPriceSeries =
     groupConsecutive(stockPrices, (p1, p2) -&gt; p1 &lt;= p2, toImmutableList())
         .collect(toImmutableList());
 </code></pre></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.7</dd>
</dl>
</li>
</ul>
<a id="groupConsecutive(java.util.stream.Stream,java.util.function.BiPredicate,java.util.function.BinaryOperator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupConsecutive</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;&nbsp;groupConsecutive&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream,
                                                              java.util.function.BiPredicate&lt;? super T,&#8203;? super T&gt;&nbsp;sameGroup,
                                                              java.util.function.BinaryOperator&lt;T&gt;&nbsp;groupReducer)</pre>
<div class="block">Groups consecutive elements from <code>stream</code> lazily. Two consecutive elements belong to the
 same group if <code>sameGroup</code> evaluates to true. Consecutive elements belonging to the same
 group will be reduced using <code>groupReducer</code>.

 <p>For example, you can find the total number of trades for the stock during each period when
 there was no large trade anomaly (difference):

 <pre><code>
 ImmutableList&lt;Long&gt; stockTradesPerPeriod =
     groupConsecutive(stockTrades, (t1, t2) -&gt; Math.abs(t1 - t2) &lt; threshold, Long::sum)
         .collect(toImmutableList());
 </code></pre></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.7</dd>
</dl>
</li>
</ul>
<a id="groupConsecutive(java.util.stream.Stream,java.util.function.Function,java.util.stream.Collector)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupConsecutive</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;R&gt;&nbsp;java.util.stream.Stream&lt;R&gt;&nbsp;groupConsecutive&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream,
                                                                      java.util.function.Function&lt;? super T,&#8203;?&gt;&nbsp;groupKeyFunction,
                                                                      java.util.stream.Collector&lt;? super T,&#8203;?,&#8203;R&gt;&nbsp;groupCollector)</pre>
<div class="block">Groups consecutive elements from <code>stream</code> lazily. Two consecutive elements belong to the
 same group if <code>groupKeyFunction</code> evaluates to equal keys. Consecutive elements belonging
 to the same group will be collected together using <code>groupCollector</code>.

 <p>For example, you can group consecutive events by their severity:

 <pre><code>
 ImmutableList&lt;ImmutableList&lt;Event&gt;&gt; sameSeverityEventGroups =
     groupConsecutive(events, Event::severity, toImmutableList())
         .collect(toImmutableList());
 </code></pre></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.7</dd>
</dl>
</li>
</ul>
<a id="groupConsecutive(java.util.stream.Stream,java.util.function.Function,java.util.function.BinaryOperator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>groupConsecutive</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;&nbsp;groupConsecutive&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream,
                                                              java.util.function.Function&lt;? super T,&#8203;?&gt;&nbsp;groupKeyFunction,
                                                              java.util.function.BinaryOperator&lt;T&gt;&nbsp;groupReducer)</pre>
<div class="block">Groups consecutive elements from <code>stream</code> lazily. Two consecutive elements belong to the
 same group if <code>groupKeyFunction</code> evaluates to equal keys. Consecutive elements belonging
 to the same group will be reduced using <code>groupReducer</code>.

 <p>For example, you can find the first event of each severity in a consecutive series of
 events:

 <pre><code>
 ImmutableList&lt;Event&gt; firstEventsWithAlternatingSeverity =
     groupConsecutive(events, Event::severity, (e1, e2) -&gt; e1)
         .collect(toImmutableList());
 </code></pre></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.7</dd>
</dl>
</li>
</ul>
<a id="runLengthEncode(java.util.stream.Stream,java.util.function.BiPredicate)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>runLengthEncode</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;<a href="BiStream.html" title="class in com.google.mu.util.stream">BiStream</a>&lt;T,&#8203;java.lang.Long&gt;&nbsp;runLengthEncode&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream,
                                                                   java.util.function.BiPredicate&lt;? super T,&#8203;? super T&gt;&nbsp;sameGroup)</pre>
<div class="block">Groups consecutive items in <code>stream</code> using the <code>sameGroup</code> predicate, along with
 the group's run length (number of items).

 <p>The following example encodes a stream of payloads with run length:

 <pre><code>
 ImmutableList&lt;RunLengthEncodedPayload&gt; encodedPayloads =
     runLengthEncode(payloads.stream(), payloadDiffer::isEquivalent)
         .mapToObj(
             (payload, count) -&gt;
                 RunLengthEncodedPayload.newBuilder()
                     .setPayload(payload)
                     .setCount(count)
                     .build())
         .collect(toImmutableList());
 </code></pre></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a BiStream with the first item of each group and the run length of that group.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>7.0</dd>
</dl>
</li>
</ul>
<a id="iterateOnce(java.util.stream.Stream)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>iterateOnce</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.lang.Iterable&lt;T&gt;&nbsp;iterateOnce&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream)</pre>
<div class="block">Iterates through <code>stream</code> <em>only once</em>. It's strongly recommended
 to avoid assigning the return value to a variable or passing it to any other method because
 the returned <code>Iterable</code>'s <code>iterator()</code> method can only be called
 once. Instead, always use it together with a for-each loop, as in:

 <pre><code>
   for (Foo foo : iterateOnce(stream)) {
     ...
     if (...) continue;
     if (...) break;
     ...
   }
 </code></pre>

 The above is equivalent to manually doing:

 <pre><code>
   Iterable&lt;Foo&gt; foos = stream::iterator;
   for (Foo foo : foos) {
     ...
   }
 </code></pre>
 except using this API eliminates the need for a named variable that escapes the scope of the
 for-each loop. And code is more readable too.

 <p>Note that <a href="#iterateThrough(java.util.stream.Stream,com.google.mu.function.CheckedConsumer)"><code>iterateThrough()</code></a> should be preferred whenever possible
 due to the caveats mentioned above. This method is still useful when the loop body needs to
 use control flows such as <code>break</code> or <code>return</code>.</div>
</li>
</ul>
<a id="iterateThrough(java.util.stream.Stream,com.google.mu.function.CheckedConsumer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>iterateThrough</h4>
<pre class="methodSignature">public static&nbsp;&lt;T,&#8203;E extends java.lang.Throwable&gt;&nbsp;void&nbsp;iterateThrough&#8203;(java.util.stream.Stream&lt;? extends T&gt;&nbsp;stream,
                                                                          <a href="../../function/CheckedConsumer.html" title="interface in com.google.mu.function">CheckedConsumer</a>&lt;? super T,&#8203;E&gt;&nbsp;consumer)
                                                                   throws E extends java.lang.Throwable</pre>
<div class="block">Iterates through <code>stream</code> sequentially and passes each element to <code>consumer</code>
 with exceptions propagated. For example:

 <pre><code>
   void writeAll(Stream&lt;?&gt; stream, ObjectOutput out) throws IOException {
     iterateThrough(stream, out::writeObject);
   }
 </code></pre></div>
<dl>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>E extends java.lang.Throwable</code></dd>
</dl>
</li>
</ul>
<a id="dice(java.util.stream.Stream,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dice</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Stream&lt;java.util.List&lt;T&gt;&gt;&nbsp;dice&#8203;(java.util.stream.Stream&lt;? extends T&gt;&nbsp;stream,
                                                                  int&nbsp;maxSize)</pre>
<div class="block">Dices <code>stream</code> into smaller chunks each with up to <code>maxSize</code> elements.

 <p>For a sequential stream, the first N-1 chunk's will contain exactly <code>maxSize</code>
 elements and the last chunk may contain less (but never 0).
 However for parallel streams, it's possible that the stream is split in roughly equal-sized
 sub streams before being diced into smaller chunks, which then will result in more than one
 chunks with less than <code>maxSize</code> elements.

 <p>This is an <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps">
 intermediary operation</a>.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>stream</code> - the source stream to be diced</dd>
<dd><code>maxSize</code> - the maximum size for each chunk</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Stream of diced chunks each being a list of size up to <code>maxSize</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if <code>maxSize &lt;= 0</code></dd>
</dl>
</li>
</ul>
<a id="dice(java.util.Spliterator,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dice</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.Spliterator&lt;java.util.List&lt;T&gt;&gt;&nbsp;dice&#8203;(java.util.Spliterator&lt;? extends T&gt;&nbsp;spliterator,
                                                                int&nbsp;maxSize)</pre>
<div class="block">Dices <code>spliterator</code> into smaller chunks each with up to <code>maxSize</code> elements.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>spliterator</code> - the source spliterator to be diced</dd>
<dd><code>maxSize</code> - the maximum size for each chunk</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>Spliterator of diced chunks each being a list of size up to <code>maxSize</code></dd>
<dt><span class="throwsLabel">Throws:</span></dt>
<dd><code>java.lang.IllegalStateException</code> - if <code>maxSize &lt;= 0</code></dd>
</dl>
</li>
</ul>
<a id="indexesFrom(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indexesFrom</h4>
<pre class="methodSignature">public static&nbsp;java.util.stream.Stream&lt;java.lang.Integer&gt;&nbsp;indexesFrom&#8203;(int&nbsp;firstIndex)</pre>
<div class="block">Returns an infinite <code>Stream</code> starting from <code>firstIndex</code>.
 Can be used together with <a href="BiStream.html#zip(java.util.Collection,java.util.Collection)"><code>BiStream.zip(java.util.Collection&lt;L&gt;, java.util.Collection&lt;R&gt;)</code></a> to iterate over a stream with index.
 For example: <code>zip(indexesFrom(0), values)</code>.

 <p>To get a finite stream, use <code>indexesFrom(...).limit(size)</code>.

 <p>Note that while <code>indexesFrom(0)</code> will eventually incur boxing cost for every integer,
 the JVM typically pre-caches small <code>Integer</code> instances (by default up to 127).</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>3.7</dd>
</dl>
</li>
</ul>
<a id="indexesFrom(long)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>indexesFrom</h4>
<pre class="methodSignature">public static&nbsp;java.util.stream.Stream&lt;java.lang.Long&gt;&nbsp;indexesFrom&#8203;(long&nbsp;firstIndex)</pre>
<div class="block">Returns an infinite index stream starting from <code>firstIndex</code>. This can then be used to
 <a href="BiStream.html#zip(java.util.Collection,java.util.Collection)"><code>zip</code></a> with another stream to provide indexing, such as:

 <pre>
   BiStream.zip(indexesFrom(0), values).toMap();
 </pre>

 <p>To get a finite stream, use <code>indexesFrom(0).limit(size)</code>.

 <p>For small indexes (up to 127), <code>Long</code> instances are pre-cached by JVM so no boxing
 happens; for larger indexes, every index incurs some boxing cost. If the cost is of concern,
 prefer to use <code>LongStream.iterate(long, java.util.function.LongUnaryOperator)</code> directly.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>5.7</dd>
</dl>
</li>
</ul>
<a id="whileNotNull(java.util.function.Supplier)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>whileNotNull</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;&nbsp;whileNotNull&#8203;(java.util.function.Supplier&lt;? extends T&gt;&nbsp;supplier)</pre>
<div class="block">Similar to <code>Stream.generate(java.util.function.Supplier&lt;? extends T&gt;)</code>, returns an infinite, sequential, ordered, and non-null
 stream where each element is generated by the provided Supplier. The stream however will
 terminate as soon as the Supplier returns null, in which case the null is treated as the
 terminal condition and doesn't constitute a stream element.

 <p>For sequential iterations, <code>whileNotNll()</code> is usually more concise than implementing
 <code>Spliterators.AbstractSpliterator</code> directly. The latter requires boilerplate that looks like this:

 <pre><code>
 return StreamSupport.stream(
     new AbstractSpliterator&lt;T&gt;(MAX_VALUE, NONNULL | ORDERED) {
       public boolean tryAdvance(Consumer&lt;? super T&gt; action) {
         if (hasData) {
           action.accept(data);
           return true;
         }
         return false;
       }
     }, false);
 </code></pre>

 Which is equivalent to the following one-liner using <code>whileNotNull()</code>:

 <pre><code>
 return whileNotNull(() -&gt; hasData ? data : null);
 </code></pre>

 <p>Why null? Why not <code>Optional</code>? Wrapping every generated element of a stream in an
 <code>Optional</code> carries considerable allocation cost. Also, while nulls are in general
 discouraged, they are mainly a problem for users who have to remember to deal with them.
 The stream returned by <code>whileNotNull()</code> on the other hand is guaranteed to never include
 nulls that users have to worry about.

 <p>If you already have an <code>Optional</code> from a method return value, you can use <code>
 whileNotNull(() -&gt; optionalReturningMethod().orElse(null))</code>.

 <p>One may still need to implement <code>AbstractSpliterator</code> or <code>Iterator</code>
 directly if null is a valid element (usually discouraged though).

 <p>If you have an imperative loop over a mutable queue or stack:

 <pre><code>
 while (!queue.isEmpty()) {
   int num = queue.poll();
   if (someCondition) {
     ...
   }
 }
 </code></pre>

 it can be turned into a stream using <code>whileNotNull()</code>:

 <pre><code>
 whileNotNull(queue::poll).filter(someCondition)...
 </code></pre></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>4.1</dd>
</dl>
</li>
</ul>
<a id="withSideEffect(java.util.stream.Stream,java.util.function.Consumer)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>withSideEffect</h4>
<pre class="methodSignature">public static&nbsp;&lt;T&gt;&nbsp;java.util.stream.Stream&lt;T&gt;&nbsp;withSideEffect&#8203;(java.util.stream.Stream&lt;T&gt;&nbsp;stream,
                                                            java.util.function.Consumer&lt;? super T&gt;&nbsp;sideEffect)</pre>
<div class="block">Returns a sequential stream with <code>sideEfect</code> attached on every element.

 <p>Unlike <code>Stream.peek(java.util.function.Consumer&lt;? super T&gt;)</code>, which should only be used for debugging purpose,
 the side effect is allowed to interfere with the source of the stream, and is
 guaranteed to be applied in encounter order.

 <p>If you have to resort to side effects, use this dedicated method instead of <code>peek()</code>
 or any other stream method. From the API specification, all methods defined by <code>Stream</code>
 are expected to be stateless, and should not cause or depend on side effects, because even for
 ordered, sequential streams, only the order of output is defined, not the order of evaluation.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>4.9</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../../../index.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/MoreStreams.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../../index-all.html">Index</a></li>
<li><a href="../../../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
<p class="legalCopy"><small>Copyright &#169; 2024. All rights reserved.</small></p>
</footer>
</body>
</html>
