╔════════════════════════════════════════════════════════════════════════════════╗
║                   GOOGLE MUG - QUICK REFERENCE GUIDE                          ║
╚════════════════════════════════════════════════════════════════════════════════╝

┌──────────────────────────────────────────────────────────────────────────────┐
│ SUBSTRING (3,170 lines) - Composable string patterns                         │
├──────────────────────────────────────────────────────────────────────────────┤
│ Static factories:                                                             │
│   prefix(String), suffix(String), first(String), first(char)                │
│   first(Pattern), last(char), consecutive(CharPredicate)                    │
│   before(Pattern), after(Pattern), between(String, String)                  │
│ Constants: NONE, BEGINNING, END                                              │
│                                                                              │
│ Pattern methods:                                                              │
│   from(String) -> Optional<Match>           # Extract match                  │
│   removeFrom(String) -> String            # Remove matched portion          │
│   replaceFrom(String, String) -> String   # Replace with string            │
│   or(Pattern) -> Pattern                  # Try alternative                 │
│   then(Pattern) -> Pattern                 # Chain patterns                 │
│   extendTo(Pattern) -> Pattern             # Extend to end pattern          │
│   skip(int) -> Pattern                     # Skip chars                     │
│   repeatedly() -> RepeatingPattern         # Match all occurrences          │
│                                                                              │
│ RepeatingPattern methods:                                                    │
│   split(String) -> Stream<Match>           # Split by pattern               │
│   replaceFrom(String, Function) -> String # Replace all matches            │
│                                                                              │
│ Example:                                                                     │
│   String domain = Substring.after(first('@')).from("user@gmail.com").get(); │
│   Substring.between("(", ")").removeFrom("func(foo)"); // => "func()"        │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ BISTREAM (2,345 lines) - Stream over key-value pairs                          │
├──────────────────────────────────────────────────────────────────────────────┤
│ Static factories:                                                             │
│   of(K, V), of(K1, V1, K2, V2, ...)           # Up to 8 pairs               │
│   from(Map<K, V>)                             # From map                     │
│   biStream(Collection<T>)                     # Index/value pairs            │
│   zip(Collection<L>, Collection<R>)           # Pair two collections        │
│   concat(BiStream...)                         # Concatenate streams          │
│                                                                              │
│ Transform:                                                                    │
│   mapKeys(Function<K, K2>)                    # Transform keys              │
│   mapValues(Function<V, V2>)                  # Transform values            │
│   map(BiFunction<K, V, Entry<K2, V2>>)        # Transform both              │
│   flatMap(BiFunction<K, V, BiStream>)         # FlatMap to pairs            │
│                                                                              │
│ Filter:                                                                      │
│   filter(BiPredicate<K, V>)                   # Filter pairs                 │
│   filterKeys(Predicate<K>)                    # Filter by key               │
│   filterValues(Predicate<V>)                  # Filter by value             │
│   skipIf(BiPredicate<K, V>)                   # Remove matching pairs       │
│                                                                              │
│ Terminal:                                                                    │
│   toMap() -> Map<K, V>                        # Collect to map              │
│   collect(BiCollector<K, V, R>) -> R          # Custom collector            │
│   keys() -> Stream<K>                         # Key stream                  │
│   values() -> Stream<V>                       # Value stream                │
│   forEach(BiConsumer<K, V>)                   # Side effect                 │
│                                                                              │
│ Example:                                                                     │
│   BiStream.from(map)                                                        │
│     .mapKeys(this::normalize)                                               │
│     .filterValues(v -> v > 0)                                               │
│     .toMap();                                                               │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ STRINGFORMAT (324 lines) - Compile-time safe string parsing                  │
├──────────────────────────────────────────────────────────────────────────────┤
│ Constructor:                                                                  │
│   StringFormat(String format)                  # "{placeholder}" syntax      │
│                                                                              │
│ Format:                                                                      │
│   format(Object... args) -> String            # Fill placeholders           │
│   static using(String template, Object...)    # Fast format (2x)           │
│                                                                              │
│ Parse:                                                                       │
│   parse(String, Function<R>) -> R             # Extract to lambda          │
│   parseOrThrow(String, Function<R>) -> R     # Throw if fail              │
│   parseOptional(String, Function<R>) -> Opt  # Optional result             │
│   scan(String, Function<R>) -> Stream<R>     # Find all occurrences        │
│                                                                              │
│ Template:                                                                    │
│   static to(Function<String, T>, String) -> Template<T>                    │
│   static template(String, Interpolator<T>) -> Template<T>                  │
│                                                                              │
│ Example:                                                                     │
│   new StringFormat("users/{uid}/posts/{pid}")                               │
│     .parse(path, (uid, pid) -> loadPost(uid, pid));                         │
│                                                                              │
│   String msg = StringFormat.using("Hello {name}", name);                    │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ BICOLLECTORS (872 lines) - Collect pairs to data structures                  │
├──────────────────────────────────────────────────────────────────────────────┤
│ Grouping:                                                                    │
│   groupingBy() -> BiCollector<K, V, Map<K, List<V>>>                       │
│   groupingBy(BinaryOperator<V>) -> Map<K, V>                               │
│   groupingByEach(Function<T, Stream<V>>)                                    │
│                                                                              │
│ Adjacency:                                                                   │
│   toAdjacentPairs() -> Collector<T, BiStream<T, T>> # (0,1), (1,2)...      │
│                                                                              │
│ Partitioning:                                                                │
│   partitioningBy(Predicate) -> Both<List, List>                             │
│                                                                              │
│ Min/Max:                                                                     │
│   minMax(Comparator) -> BiOptional<T, T>                                    │
│   allMin(Comparator, Collector)                                              │
│   allMax(Comparator, Collector)                                              │
│                                                                              │
│ Fixed size:                                                                  │
│   onlyElement() -> FixedSizeCollector<T, ?, R>                              │
│   onlyElements(int) -> FixedSizeCollector<T, ?, List<T>>                    │
│   combining(MapFrom3-8<T, R>) -> FixedSizeCollector                         │
│                                                                              │
│ Example:                                                                     │
│   Map<City, Household> richest = households.stream()                         │
│     .collect(groupingBy(Household::city, this::richer))                      │
│     .toMap();                                                               │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ PARALLELIZER (594 lines) - Structured concurrency for IO                    │
├──────────────────────────────────────────────────────────────────────────────┤
│ Constructor:                                                                  │
│   Parallelizer(ExecutorService, int maxConcurrency)                         │
│                                                                              │
│ Parallelize:                                                                 │
│   parallelize(Stream<T>, Consumer<T>)                                      │
│   parallelize(Stream<T>, Consumer<T>, Duration)                             │
│   parallelizeUninterruptibly(Stream<T>, Consumer<T>)                        │
│   parallelize(Stream<Runnable>)                                             │
│                                                                              │
│ Collector:                                                                   │
│   inParallel(Function<I, O>) -> Collector<I, ?, BiStream<I, O>>            │
│                                                                              │
│ Example:                                                                     │
│   new Parallelizer(executor, 10)                                             │
│     .parallelize(items.stream(), this::processItem);                        │
│                                                                              │
│   BiStream<Input, Output> results = inputs.stream()                          │
│     .collect(parallelizer.inParallel(this::process));                       │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ GRAPHWALKER (385 lines) - Graph traversal algorithms                         │
├──────────────────────────────────────────────────────────────────────────────┤
│ Factory:                                                                     │
│   Walker.inGraph(Function<N, Stream<N>>)  # With cycles                     │
│   Walker.inTree(Function<N, Stream<N>>)  # Without cycles                   │
│                                                                              │
│ Traversal:                                                                   │
│   preOrderFrom(Iterable<N>) -> Stream<N>      # Depth-first, pre-order      │
│   postOrderFrom(Iterable<N>) -> Stream<N>     # Depth-first, post-order     │
│   breadthFirstFrom(Iterable<N>) -> Stream<N>  # Breadth-first               │
│   topologicalOrderFrom(Iterable<N>) -> List<N> # Throws if cyclic           │
│   detectCycleFrom(Iterable<N>) -> Optional<Stream<N>>                       │
│   stronglyConnectedComponentsFrom(Iterable<N>) -> Stream<List<N>>           │
│                                                                              │
│ Example:                                                                     │
│   List<Node> order = Walker.inGraph(n -> n.getDependencies())                │
│     .topologicalOrderFrom(root);                                            │
│                                                                              │
│   Optional<Stream<Node>> cycle = Walker.inGraph(successors)                  │
│     .detectCycleFrom(start);                                                │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ ITERATION (448 lines) - Lazy recursion without stack overflow                │
├──────────────────────────────────────────────────────────────────────────────┤
│ Emit:                                                                        │
│   emit(T)                    # Emit single value                            │
│   emit(T[])                  # Emit array                                   │
│   emit(Iterable<T>)           # Emit collection                             │
│   emit(Stream<T>)             # Emit stream                                 │
│                                                                              │
│ Lazy:                                                                        │
│   lazily(Runnable)            # Defer recursive call                        │
│                                                                              │
│ Control:                                                                     │
│   ifElse(boolean, Runnable, Runnable)                                       │
│   whileTrue(BooleanSupplier, Runnable)                                      │
│   forIndices(int, int, IntConsumer)                                         │
│                                                                              │
│ Execute:                                                                     │
│   iterate() -> Stream<T>        # Execute and return stream                 │
│                                                                              │
│ Example:                                                                     │
│   Stream<Foo> allFoos = new Iteration<Foo>() {                              │
│     Foos paginate(Request req) {                                            │
│       Response res = service.list(req);                                     │
│       emit(res.getFoos());                                                 │
│       if (!res.getNextPageToken().isEmpty()) {                              │
│         lazily(() -> paginate(req.withToken(res.getNextPageToken())));      │
│       }                                                                     │
│       return this;                                                          │
│     }                                                                       │
│   }.paginate(initialRequest).iterate();                                      │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ SAFESQL (2,850 lines module) - Library-enforced safe SQL                    │
├──────────────────────────────────────────────────────────────────────────────┤
│ Factory:                                                                     │
│   static of(String template, Object... args)                                │
│   static of(QueryOptions, String template, Object... args)                  │
│                                                                              │
│ Compose:                                                                     │
│   and(SafeSql)                   # Add AND clause                           │
│   or(SafeSql)                    # Add OR clause                            │
│   with(String clause, Object...) # Add custom clause                       │
│                                                                              │
│ Execute:                                                                     │
│   toString() -> String            # Get SQL string                          │
│   parameters() -> List<Object>    # Get parameters                          │
│   query(ResultMapper<T>, Connection) -> List<T>                            │
│   querySingle(ResultMapper<T>, Connection) -> Optional<T>                  │
│   execute(StatementSetter)                                                │
│                                                                              │
│ Template syntax:                                                             │
│   {column}         # Identifier (backtick-quoted)                            │
│   {value}          # Value parameter (?)                                     │
│   'literal'        # Single-quoted literal                                   │
│                                                                              │
│ Example:                                                                     │
│   SafeSql query = SafeSql.of(                                                │
│     "SELECT `{cols}` FROM Users WHERE id = {id}",                           │
│     "name, email", userId);                                                 │
│                                                                              │
│   List<User> users = query.query(UserMapper, connection);                   │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ MORECOLLECTORS (750 lines) - Advanced collectors                             │
├──────────────────────────────────────────────────────────────────────────────┤
│ Mapping:                                                                     │
│   mapping(Function<T, F>, Collector<F, ?, R>)                              │
│   flatMapping(Function<T, Stream<F>>, Collector)                            │
│                                                                              │
│ Fixed size (throws if wrong count):                                          │
│   onlyElement() -> FixedSizeCollector<T, ?, R>                              │
│   onlyElements(int n) -> FixedSizeCollector<T, ?, List<T>>                  │
│   combining(MapFrom3-8<T, R>) -> FixedSizeCollector                         │
│                                                                              │
│ Partitioning:                                                                │
│   partitioningBy(Predicate, Collector, Collector) -> Both<R, R>             │
│                                                                              │
│ Min/Max:                                                                     │
│   minMax(Comparator) -> BiOptional<T, T>                                    │
│   allMin(Comparator, Collector)                                              │
│   allMax(Comparator, Collector)                                              │
│                                                                              │
│ Switching:                                                                   │
│   switching(Predicate, Collector then, Collector otherwise)                 │
│                                                                              │
│ Post-process:                                                                │
│   toListAndThen(Consumer<List<T>>)                                          │
│                                                                              │
│ Example:                                                                     │
│   Result res = stream.collect(onlyElements(3).andThen(this::build));        │
│                                                                              │
│   List<Product> cheapest = products.stream()                                │
│     .collect(allMin(Comparator.comparing(Product::price), toList()));       │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ MORESTREAMS (642 lines) - Stream utilities                                   │
├──────────────────────────────────────────────────────────────────────────────┤
│ Creation:                                                                    │
│   whileNotNull(Supplier<T>) -> Stream<T>          # While supplier non-null  │
│   withSideEffect(Stream<T>, Consumer<T>)          # Add side effect          │
│   iterateOnce(Iterator<T>) -> Stream<T>           # Single-use stream       │
│   concat(Stream<T>...) -> Stream<T>               # Concatenate             │
│   zip(Stream<L>, Stream<R>) -> Stream<Entry<L,R>> # Pair streams           │
│                                                                              │
│ Example:                                                                     │
│   Stream<Item> items = MoreStreams.whileNotNull(queue::poll);               │
└──────────────────────────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────────────────────────┐
│ FUNCTIONAL INTERFACES - Throw checked exceptions                            │
├──────────────────────────────────────────────────────────────────────────────┤
│ CheckedFunction<T, R>          R apply(T) throws Throwable                   │
│ CheckedConsumer<T>             void accept(T) throws Throwable              │
│ CheckedSupplier<T>             T get() throws Throwable                     │
│ CheckedRunnable                void run() throws Throwable                   │
│ CheckedBiFunction<T, U, R>     R apply(T, U) throws Throwable               │
│ CheckedBiConsumer<T, U>        void accept(T, U) throws Throwable           │
│ CheckedBiPredicate<T, U>       boolean test(T, U) throws Throwable          │
│ CheckedIntConsumer             void accept(int) throws Throwable            │
│                                                                              │
│ Arity-specific:                                                               │
│ TriFunction<T, U, V, R>         R apply(T, U, V)                             │
│ Function4<T, U, V, W, R>        R apply(T, U, V, W)                          │
│ MapFrom3<T, R>                 R map(T, T, T)                               │
│ MapFrom4-8<T, R>                R map(T, T, T, T...)                        │
└──────────────────────────────────────────────────────────────────────────────┘

╔════════════════════════════════════════════════════════════════════════════════╗
║  For full documentation, see: comprehensive-mug-analysis.md                   ║
╚════════════════════════════════════════════════════════════════════════════════╝
